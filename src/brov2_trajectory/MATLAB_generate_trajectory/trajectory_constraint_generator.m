%% Generate supported path [out-n-back, side-to-side]
clear, clc;
surge_velocity              = 10;
turn_radius                 = 10;
line_distance               = 50;
number_of_lines             = 8;
turn_velocity_percentage    = 80;
start_point                 = [20,20,0];
start_angle                 = 0;
start_time                  = 0;
end_point                   = [0,10,0];
path_type                   = "side-to-side";
turn_direction              = "left";

if path_type == "out-n-back"
    path_constraints = generate_out_and_back_trajectory_constraints(start_point,                ...
                                                                    start_angle,                ...
                                                                    end_point,                  ...
                                                                    surge_velocity,             ...
                                                                    turn_velocity_percentage,   ...
                                                                    number_of_lines,            ...
                                                                    turn_radius,                ...
                                                                    line_distance,              ...
                                                                    turn_direction)
elseif path_type == "side-to-side"
    path_constraints = generate_side_to_side_trajectory_constraints(start_point,                ...
                                                                    start_angle,                ...
                                                                    end_point,                  ...
                                                                    surge_velocity,             ...
                                                                    turn_velocity_percentage,   ...
                                                                    number_of_lines,            ...
                                                                    turn_radius,                ...
                                                                    line_distance,              ...
                                                                    turn_direction)  
else
    error('Use a valid trajectory type.')
end

%% Orient the path with start_angle in NED (clockwise = positive, degrees) 
oriented_path_constraints = orient_path_constraints(start_angle,            ...
                                                    turn_radius,            ...
                                                    line_distance,          ...
                                                    path_constraints,       ...
                                                    path_type)



%% Add time constraint to path (remember to add depth values manually before doing this step)
trajectory_constraints = add_timing_constraints(start_time,                 ...
                                                surge_velocity,             ...
                                                turn_velocity_percentage,   ...
                                                turn_radius,                ...
                                                oriented_path_constraints,  ...
                                                path_type)
                                                                                                           
if trajectory_constraints(:,4) == 0
    warning('Remember to set depth manually before generating time constraints.') 
end
if ismember(diff(trajectory_constraints(:,1)),0)
    warning('Two or more time stamps are the same. Adding 0.0001 to avoid error during generating trajectory.')
    %index = find(diff(trajectory_constraints(:,1))==0) + 1;
    %trajectory_constraints(index,1) = trajectory_constraints(index,1) + 0.0001;
end